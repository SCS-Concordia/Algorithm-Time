var util       = require("util");
var indigenous = require("indigenous");

function Validation(value) {
    this._value = value;
}

Validation.success = 0;
Validation.failure = 1;

Validation.prototype._value = undefined;

Validation.prototype.concat = function(other) {
    throw new Error("Validation subtype must implement #concat()");
};

Validation.empty = function() {
    return new Success(true);
};

Validation.prototype.map = function(mapper) {
    throw new Error("Validation subtype must implement #map()");
};

Validation.prototype.ap = function(next) {
    throw new Error("Validation subtype must implement #ap()");
};

Validation.of = function(fn) {
    return new Success(fn);
};

Validation.prototype.flatMap = function(flatMapper) {
    throw new Error("Validation subtype must implement #flatMap()");
};

Validation.prototype.chain = Validation.prototype.flatMap;

Validation.prototype.fold = function(failure, success) {
    throw new Error("Validation subtype must implement #fold()");
};

Validation.prototype.type = function() {
    throw new Error("Validation subtype must implement #type()");
};

Validation.prototype.toNative = function() {
    throw new Error("Validation subtype must implement #toNative()");
};


function Success(value) {
    Validation.call(this, value);
}

util.inherits(Success, Validation);

Success.prototype.concat = function(other) {
    switch(other.type()) {
        case Validation.success: return this;
        case Validation.failure: return other;
    }
};

Success.prototype.map = function(mapper) {
    return new Success(mapper(this._value));
};

Success.prototype.ap = function(next) {
    return next.map(this._value);
};

Success.prototype.flatMap = function(flatMapper) {
    return flatMapper(this._value);
};

Success.prototype.chain = Success.prototype.flatMap;

Success.prototype.fold = function(failure, success) {
    return success(this._value);
};

Success.prototype.type = function() {
    return Validation.success;
};

Success.prototype.toNative = function() {
    return {
        status:  "ok",
        message: indigenous(this._value)
    };
};


function Failure(value) {
    Validation.call(this, value);
}

util.inherits(Failure, Validation);

Failure.prototype.concat = function(other) {
    var self = this;
    return other.fold(
        function(failure) { return new Failure(self._value.concat(failure)); },
        function(success) { return self; }
    );
};

Failure.prototype.map = function(mapper) {
    return this;
};

Failure.prototype.ap = function(next) {
    switch(next.type()) {
        case Validation.failure: return this.concat(next);
        case Validation.success: return this;
    }
};

Failure.prototype.flatMap = function(flatMapper) {
    return this;
};

Failure.prototype.chain = Failure.prototype.flatMap;

Failure.prototype.fold = function(failure, success) {
    return failure(this._value);
};

Failure.prototype.type = function() {
    return Validation.failure;
};

Failure.prototype.toNative = function() {
    return {
        status:  "error",
        message: indigenous(this._value)
    };
};


Validation.Success = Success;

Validation.Failure = Failure;

module.exports = Validation;
