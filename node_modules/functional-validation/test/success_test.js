var assert     = require("assert");
var Validation = require("../index");
var Success    = require("../success");
var Failure    = require("../failure");

describe("Success", function() {

    describe("when calling concat w/ a Success", function() {
        before(function() {
            var success = new Success(1);
            this.result = success.concat(new Success(2));
        });

        it("should return a Success", function() {
            assert.ok(this.result instanceof Success);
        });
        it("should return the first Success", function() {
            assert.equal(this.result._value, 1);
        });
    });

    describe("when calling concat w/ a Failure", function() {
        before(function() {
            var success = new Success(1);
            this.result = success.concat(new Failure(["error"]));
        });

        it("should return a Failure", function() {
            assert.ok(this.result instanceof Failure);
        });
    });

    describe("when calling a map w/ a mapper", function() {
        before(function() {
            var success = new Success(1);
            this.result = success.map(function(n) { return n + 1; });
        });

        it("should return a Success", function() {
            assert.ok(this.result instanceof Success);
        });
        it("should have applied the mapper", function() {
            assert.equal(this.result._value, 2);
        });
    });

    describe("when passing to an #ap", function() {
        before(function() {
            var n = new Success(1);
            this.result = Validation.of(function(n) { return n + 1; }).ap(n);
        });

        it("should return success", function() {
            assert.ok(this.result instanceof Success);
        });
        it("should have applied the operation", function() {
            assert.equal(this.result._value, 2);
        });
    });

    describe("when returning Success from flatMap", function() {
        before(function() {
            var success = new Success(1);
            this.result = success.flatMap(function(n) {
                return new Success(n + 1);
            });
        });

        it("should return success", function() {
            assert.ok(this.result instanceof Success);
        });
        it("should have applied the flatMapper", function() {
            assert.equal(this.result._value, 2);
        });
    });

    describe("when returning Failure from flatMap", function() {
        before(function() {
            var success = new Success(1);
            this.result = success.flatMap(function(n) {
                return new Failure(["error"]);
            });
        });

        it("should return failure", function() {
            assert.ok(this.result instanceof Failure);
        });
        it("should have applied the flatMapper", function() {
            assert.deepEqual(this.result._value, ["error"]);
        });
    });

    describe("when returning Success from chain", function() {
        before(function() {
            var success = new Success(1);
            this.result = success.chain(function(n) {
                return new Success(n + 1);
            });
        });

        it("should return success", function() {
            assert.ok(this.result instanceof Success);
        });
        it("should have applied the chain", function() {
            assert.equal(this.result._value, 2);
        });
    });

    describe("when returning Failure from chain", function() {
        before(function() {
            var success = new Success(1);
            this.result = success.chain(function(n) {
                return new Failure(["error"]);
            });
        });

        it("should return failure", function() {
            assert.ok(this.result instanceof Failure);
        });
        it("should have applied the chain", function() {
            assert.deepEqual(this.result._value, ["error"]);
        });
    });

    describe("when calling fold", function() {
        before(function() {
            var success = new Success(1);
            this.result = success.fold(
                function(error) { return false; },
                function(value) { return true; }
            );
        });

        it("should have applied the success case", function() {
            assert.equal(this.result, true);
        });
    });

    describe("when calling type", function() {
        before(function() {
            var success = new Success(1);
            this.result = success.type();
        });

        it("should return the success value", function() {
            assert.equal(this.result, Validation.success);
        });
    });

    describe("when calling toNative", function() {
        before(function() {
            var success = new Success(42);
            this.result = success.toNative();
        });

        it("should return the native representation", function() {
            assert.deepEqual(this.result, {
                "status":"ok",
                "message": 42
            });
        });
    });

});
